# javaScrtip-1-
# [17조]주특기 주차 팀 노션(Node.js)

[팀원 정보](https://www.notion.so/7d7ec7a770e34241a8673e36c9b9b55d)

<aside>
🔐 for 문이 있는데 for ... in for...of 문법이 새로 나온 이유는 무엇일까요? 우리가 이것을 고르는 기준은 무엇일까요?

</aside>

**for 문 :** for문은 JS의 가장 기본적인 반복문 중 하나로, for문을 사용하면 이터러블(iterable) 객체를 반복 처리 할 수 있지만, 객체의 속성 즉, 프로퍼티를 열거하기는 어렵다. 

인덱스와 값을 모두 사용해야 하는 경우에는 for문을 사용하는 것이 더 직관적인 코드를 만들 수 있다.

**for ... in :** for문의 단점을 보완하기 위해 ****ECMAScript 1에서 객체의 속성을 열거하기 위한 for…in 반복문이 추가 되었다. 다만, 객체의 프로토타입 체인 상의 속성도 열거할 수 있다는 문제와 열거한 속성의 순서가 보장되지 않는 문제점이 있었다.
개체의 속성 값을 추출하거나 조작하려는 경우와 같이 개체의 속성을 반복해야 할 때 자주 사용된다.

**for ... of :** 이후 ES6에서 이터러블 객체(array, map, set, arguments)를 순회하기 위한 목적으로 for…of 반복문이 추가되었다.

각 요소 값을 각 반복의 변수에 할당하여 인덱스가 아닌 값 자체로 작업하기가 더 쉽습니다.

반복문을 고르는 기준은 마주한 상황에 따라 다르다. for문의 한계를 보완하기 위해 추가된 문법일 뿐 무조건 for…in, for…of 반복문이 적절한 것은 아니다.

- **최다현**
    
    for문은 JS의 가장 기본적인 반복문 중 하나로, for문을 사용하면 이터러블(iterable) 객체를 반복 처리 할 수 있는데 객체의 속성 즉, 프로퍼티를 열거하기는 어렵다.
    이 때문에 ECMAScript 1에서 객체의 속성을 열거하기 위한 for…in 반복문이 추가 되었다.
    **for…in을 사용하여 객체의 속성을 하나씩 열거하여 반복처리** 할 수 있게 되었지만,
    객체의 프로토타입 체인 상의 속성도 열거할 수 있다는 문제와 열거한 속성의 순서도 보장되지 않는 문제 점이 있었다.
    이후 ES6에서 이터러블 객체를 순회하기 위한 목적으로 for…of 반복문이 추가되었다.
    **for...of 반복문은 객체의 속성이 아닌 값을 열거**하기 때문에, 객체의 프로토타입 체인 상의 속성을 열거하는 문제를 해결할 수 있고, 순서가 보장되는 이터러블 객체를 순회하기에 **for…in과 달리
    예상치 못한 결과를 얻을 확률이 매우 적다.**
    반복문을 고르는 기준은 마주한 상황에 따라 다르다. for문의 한계를 보완하기 위해 추가된 문법일 뿐 **무조건 for…in, for…of 반복문이 적절한 것은 아니다.**
    
    - 인덱스와 값을 모두 사용해야 하는 경우에는 for문을 사용하는 것이 더 직관적인 코드를 만들 수 있다.
    - 객체의 속성을 열거 할 때는 for…in 반복문을 사용하는 것이 적절하다.
    - 이터러블 객체(배열, 문자열, map, Set 등)를 순회할 때는 for…of 반복문을 사용하는 것이 적절하다.
- 이건선
    
    **`for...in`**
     루프는 개체의 속성을 반복하는 데 사용됩니다. 프로토타입 체인에서 상속된 속성을 포함하여 개체의 모든 열거 가능한 속성을 반복하여 작동합니다. 개체의 속성 값을 추출하거나 조작하려는 경우와 같이 개체의 속성을 반복해야 할 때 자주 사용됩니다.
    
    **`for. ..of`**
     루프는 배열이나 문자열과 같은 반복 가능한 객체의 값을 반복하는 데 사용됩니다. 기존의 **`for`**
     루프에 비해 반복 가능한 객체를 반복하는 더 간결하고 읽기 쉬운 방법으로 ES6에 도입되었습니다. iterable의 각 요소 값을 각 반복의 변수에 할당하여 인덱스가 아닌 값 자체로 작업하기가 더 쉽습니다.
    
- 문지혜
    
    for 문 : 인덱스 값을 사용하는 경우 더 유용
    
    for in : 객체에서 모든 열거 가능한 프로퍼티를 순회, 해당 프로퍼티의 이름을 열거
    
    for of: 이터러블 객체(array, map, set, arguments)를 순회, 해당 프로퍼티의 값을 열거
    
- 송종호
    
    for of 는 배열의 반복에서 사용되고,
    for in은 객체의 반복에서 사용된다.
    

<aside>
🔐 restAPI의 put 과 patch 는 어떤 차이점이 있을까요? 어떤 경우에 사용하면 좋을까요?

</aside>

REST API에서 PUT과 PATCH는 모두 **리소스를 수정하기 위한 HTTP 메서드 이다.**

- **PUT :** PUT 메서드는 **전체 리소스를 업데이트**하는데 사용된다.
즉, ****클라이언트가 서버로 전송한 데이터가 리소스의 전체 내용으로 대체된다.
이때, 요청된 리소스가 존재하지 않는다면, PUT 메서드는 **해당 리소스를 생성한다.**
PUT 메서드는 전체 리소스를 대체하므로, 클라이언트는 PUT 요청을 할 때 **모든 필수 필드를 포함하여 전체 리소스를 제공해야 한다.**
- ********PATCH :******** PATCH 메서드는 **리소스의 일부를 수정**하는데 사용된다. 
즉, 클라이언트가 서버로 전송한 데이터가 리소스의 일부를 수정하는데 사용된다.
이때, 요청된 리소스가 존재하지 않는다면, PATCH 메서드는 **새로운 리소스를 생성하지 않는다.**
PATCH 메서드는 리소스의 일부를 수정하므로, 클라이언트는 **수정하고자 하는 필드만 전송하면 된다.**

적절한 예시로 **게시글 전체 내용을 수정**하고자 할 때는 PUT메서드를,
**게시글의 일부만 수정**하고자 할 때는 PATCH 메서드를 사용하는 것이 적절하다.

- **최다현**
    
    REST API에서 PUT과 PATCH는 모두 **리소스를 수정하기 위한 HTTP 메서드 이다.**
    
    - **PUT :** PUT 메서드는 **전체 리소스를 업데이트**하는데 사용된다.
    즉, ****클라이언트가 서버로 전송한 데이터가 리소스의 전체 내용으로 대체된다.
    이때, 요청된 리소스가 존재하지 않는다면, PUT 메서드는 **해당 리소스를 생성한다.**
    PUT 메서드는 전체 리소스를 대체하므로, 클라이언트는 PUT 요청을 할 때 **모든 필수 필드를 포함하여 전체 리소스를 제공해야 한다.**
    - ********PATCH :******** PATCH 메서드는 **리소스의 일부를 수정**하는데 사용된다. 
    즉, 클라이언트가 서버로 전송한 데이터가 리소스의 일부를 수정하는데 사용된다.
    이때, 요청된 리소스가 존재하지 않는다면, PATCH 메서드는 **새로운 리소스를 생성하지 않는다.**
    PATCH 메서드는 리소스의 일부를 수정하므로, 클라이언트는 **수정하고자 하는 필드만 전송하면 된다.**
    
    적절한 예시로 **게시글 전체 내용을 수정**하고자 할 때는 PUT메서드를,
    **게시글의 일부만 수정**하고자 할 때는 PATCH 메서드를 사용하는 것이 적절하다.
    
- 이건선
    
    PUT: 전체 리소스를 업데이트하거나 교체하는 데 사용됩니다.
    
    PATCH: 반면에 PATCH 방법은 리소스의 일부를 업데이트하는 데 사용됩니다. 리소스의 작은 부분만 수정하면 되는 경우 PATCH가 PUT보다 더 효율적입니다.
    
- 송종호
    
    PUT 메소드는 클라이언트가 전체 리소스를 업데이트할 때 사용됩니다.
    요청한 데이터로 리소스를 완전히 교체합니다.
    PUT 요청을 보내면, 해당 리소스가 존재하면 업데이트하고, 존재하지 않으면 새로운 리소스를 생성합니다.
    
    PATCH 메소드는 클라이언트가 리소스의 일부분만 업데이트할 때 사용됩니다.
    요청한 데이터만큼의 수정을 합니다. 이는 리소스의 일부분만 업데이트하므로 전체 리소스를 다시 보내지 않아도 됩니다.
    
    예시)회원 정보를 수정할 때, PUT 요청을 사용하면 모든 회원 정보를 보내야 하지만 PATCH 요청을 사용하면 변경하고자 하는 정보만 보낼 수 있습니다
    
- 문지혜
    
    PUT: PUT 메서드는 요청한 URI에 payload(ex. Request Body)에 있는 자원으로 **대체(replace)**
    하는 메서드. **PUT 메서드를 사용하는 클라이언트는 해당 자원의 상태를 모두 알고 있다고 가정되어야 한다. 청 경로에 자원이 존재하는 경우 해당 자원을 payload 정보와 교체하는 메서드므로** 전송하는 **payload만으로 자원의 전체 상태를 나타낼 수 있어야 한다.**
    PATCH: RFC 문서에 따르면 PATCH 요청은 자원에 대한 **부분적인 수정을 적용**하기 위한 HTTP 메서드이다. PATCH는 부분 수정을 위한 데이터만 요청의 payload로 보내기 때문에 body를 받는 DTO를 별도로 만들어 주어야 하고, 이 부분 데이터를 받는 DTO로는 새로운 엔티티를 생성할 수 없고 오직 부분 수정을 위한 데이터로써의 준비를 마치게 된다.
    

<aside>
🔐 몽고DB로 테이블 설계를 해봅시다. 회원가입을 한 유저가 게시판에 글을 쓰는 서비스입니다. 게시판 목록 페이지에서는 게시글 제목, 작성자 이름 등이 보이겠죠? 각각의 모델은 어떤 모양새이면 좋을까요? 게시판 글 리스트를 불러오는 api 에서는 몽구스 데이터를 어떻게 가져오면 좋을까요?

</aside>

users Collection

**const mongoose = require('mongoose');

const userSchema = new mongoose.Schema({
username: {
type: String,
required: true,
unique: true
},
password: {
type: String,
required: true
},
email: {
type: String,
required: true,
unique: true
}
});

const User = mongoose.model('User', userSchema);

module.exports = User;**

board Collection

**const mongoose = require('mongoose');

const postSchema = new mongoose.Schema({
title: {
type: String,
required: true
},
content: {
type: String,
required: true
},
author: {
type: mongoose.Schema.Types.ObjectId,
ref: 'User'
},
createdAt: {
type: Date,
default: Date.now
}
});

const Post = mongoose.model('Post', postSchema);

module.exports = Post;**

- **최다현**
    
    몽고 DB는 컬렉션을 사용하여 데이터를 저장하는데,
    
    - 회원 정보 컬렉션 : 회원 가입 시 입력한 정보를 저장하는 테이블을 생성한다.
    - 게시글 컬렉션 : 회원이 작성한 게시글의 정보를 저장하는 테이블을 생성한다.
    
    이렇게 두가지 컬렉션으로 분리하는 것이 적절해 보인다.
    실제로 풀스택 프로젝트에서 컬렉션을 하나로 운영했을 때, 원하는 정보만 가져오는 코드를 짜는 것에 많은 시간을 허비한 경험이 있다. 뒤를 부탁합니다.
    
- 이건선
    
    사용자용이고 다른 하나는 게시물용 스키마를 만듭니다. 그리고 사용자용 스키마는 사용자의 이름, 패스워드를 넣고 게시물용 스키마에는 글의 제목과 안에 들어갈 내용 그리고 누가 작성했는지에 관한 스키마를 넣습니다.
    
- 문지혜
    
    -users: 
    
    -boards: user(id, unique, name), contents(title, content), info(time, ip..)
    
- 송종호
    
    [https://meetup.nhncloud.com/posts/276](https://meetup.nhncloud.com/posts/276)
    

<aside>
🔐 우리가 브라우저에서 구매한 도메인 주소를 입력하면 만들어 놓은 aws EC2 서버까지 전달이 되어서 해당 서버에게 요청을 보낼 수 있습니다. 이 과정이 상세하게 어떻게 진행되는지 그림으로 한번 그려볼까요?

</aside>

1. 브라우저에서 구매한 도메인 주소를 입력하면, 이 도메인 주소는 DNS(Domain Name System) 서버에서 IP 주소로 변환된다.
2. 변환된 IP 주소는 해당 EC2 서버에 요청을 보내기 위해 인터넷을 통해 전송된다.
3. EC2 서버는 해당 요청을 받고, 필요한 처리를 수행한 후, 결과를 다시 브라우저에게 전송한다
4. 브라우저는 서버에서 받은 결과를 해석하여 화면에 표시한다.

![서버, 브라우저 통신과정.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/d496e4eb-ff12-46ee-bd85-8d345c7e549a/%EC%84%9C%EB%B2%84_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80_%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95.jpg)

- **최다현**
    1. 브라우저에서 구매한 도메인 주소를 하면, 이 도메인 주소는 DNS(Domain Name System) 서버에서 IP 주소로 변환된다.
    2. 변환된 IP 주소는 해당 EC2 서버에 요청을 보내기 위해 인터넷을 통해 전송된다.
    3. EC2 서버는 해당 요청을 받고, 필요한 처리를 수행한 후, 결과를 다시 브라우저에게 전송한다
    4. 브라우저는 서버에서 받은 결과를 해석하여 화면에 표시한다.
    
    ![서버, 브라우저 통신과정.jpg](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/6ebfebad-d790-4a32-bf64-d6ff3387d9c1/%EC%84%9C%EB%B2%84_%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80_%ED%86%B5%EC%8B%A0%EA%B3%BC%EC%A0%95.jpg)
    
- 이건선
    
    1. 클라이언트(사용자)가 도메인주소를 입력하면
    
    2. ISP 네임서버는 가비아 네임서버에서 IP주소를 가져와서 사용자에게 알려준다.
    
    3. 그럼 사용자는 IP주소로 웹서버에 다시 요청하고 요청한 데이터를 응답받는다.
    
    ![img.png](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/9e83f970-8b6b-4082-babb-2a1171d2870c/img.png)
    
- 문지혜
    
    ![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/5aaae7f8-91a7-4544-a1a8-b1d498671230/Untitled.png)
    
- 송종호
    
    도메인 주소를 입력하면, 브라우저는 DNS(Domain Name System) 서버에게 해당 도메인 이름을 IP 주소로 변환하는 요청을 보냅니다.
    DNS 서버는 도메인 이름에 해당하는 IP 주소를 찾아서 브라우저에게 응답합니다.
    
    브라우저는 이제 해당 IP 주소에 대한 HTTP 요청을 생성하고, 이를 해당 IP 주소에 해당하는 EC2 서버(아마존 서버)에 전송합니다.
    이 요청은 TCP/IP 프로토콜(통신 프로토콜)을 사용하여 전송되며, 요청에는 HTTP 메서드(GET, POST, PUT, DELETE 등)와 함께 요청하는 리소스의 경로 등이 포함됩니다.
    
    EC2 서버는 요청을 받으면, 해당 요청에 맞는 웹 애플리케이션 또는 웹 서버를 실행시켜 요청에 대한 처리를 시작합니다.
    웹 서버는 요청을 받으면, 처리를 위해 필요한 데이터베이스나 다른 서비스와 연결하여 데이터를 가져오고, 처리한 결과를 다시 클라이언트(브라우저)에게 응답합니다.
    
    응답은 HTTP 응답 메시지로 전송되며, 이 메시지에는 상태 코드(200 OK, 404 Not Found 등), 응답 바디(HTML, JSON 등), 응답 헤더 등이 포함됩니다
    이를 통해 브라우저는 서버로부터 받은 응답을 처리하여 화면에 웹 페이지를 렌더링하게 됩니다.
    
    [https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FtXRpJ%2FbtqDKphnSph%2FR5ruRUWglQhwJo43zvF7E1%2Fimg.png](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FtXRpJ%2FbtqDKphnSph%2FR5ruRUWglQhwJo43zvF7E1%2Fimg.png)
    

# DIY Section

<aside>
🔑 Q1. 이번 주차의 중요 키워드를 선정하고, 이것을 정리하는 질문과 답변을 만들어 주세요 :-)

</aside>

**논 블로킹(Non-blocking) :** 일부 코드가 **실행되는 동안** 다른 코드가 차단되지 않는 것을 의미한다.

**REPL(Read-Eval-Print Loop) :** JavaScript 코드를 입력하고 즉시 실행하고 결과를 출력하는 대화형 프로그래밍 환경이다.

**API client :** 웹 애플리케이션에서 RESTful API와 같은 서버에서 데이터를 가져오는 데 사용되는 클라이언트이다.

**Routing :** 웹 프레임워크에서 URL 경로를 해당 기능과 연결하는 방식을 말한다.

**미들웨어(Middle ware) :** 미들웨어는 웹 애플리케이션에서 **요청과 응답 사이의 처리를 담당**하는 함수이다. 미들웨어는 웹 애플리케이션의 요청과 응답 사이에 위치하여, 요청이 처리되기 전이나 응답이 클라이언트로 전송되기 전에 해당 요청과 응답을 가로채고 처리할 수 있다.

**모듈(Module) :** 자바스크립트 코드를 재사용 가능한 **독립적인 조각으로 나누어 관리하는 방법**이다.
관련된 변수, 함수, 객체 등을 하나의 파일에 묶어서 관리하며, 이를 다른 코드에서 불러와 사용할 수 있다.

**Request, Response :** 웹 애플리케이션에서 클라이언트와 서버 간에 주고받는 데이터를 나타낸다.
Request는 **클라이언트에서 서버로 전송되는 데이터**를 나타내며, 일반적으로 HTTP 메서드(GET, POST, PUT, DELETE 등)와 URL, 헤더 등의 정보를 포함합니다. Request 객체는 서버 측에서 처리되어 **Response 객체를 반환**한다.

<aside>
🔑 Q2. 이번 주차의 중요 키워드를 선정하고, 이것을 정리하는 질문과 답변을 만들어 주세요 :-)

</aside>

new Promise(executor) 코드로 Promise 를 직접 생성하면 executor가 바로 실행되는 것과 달리, 비동기 함수는 함수가 실행되기 전까지 Promise를 생성하지 않습니다.

payload 설명 (데이터, 실질적인 데이터)

서버가 응답을 보낼 때에는 항상 Payload를 보낼 수 있습니다.
클라이언트(브라우저)가 요청을 할 때에도 Payload를 보낼 수 있습니다.
그리고 "GET method를 제외하곤 모두 Payload를 보낼 수 있다"는게 HTTP에서의 약속입니다.

<aside>
🔑 Q3. 이번 주차의 중요 키워드를 선정하고, 이것을 정리하는 질문과 답변을 만들어 주세요 :-)

</aside>

**송종호**

노드 js  : 브라우져 없이 실행 하게 도와주는 환경

**논블로킹 : 실행되는 중에도 다른 작업을 동시에 진행 가능**

싱글스레드 : 스레드(프로그램 동작때 cpu or 프로세서 사용 단위)를 하나를 사용하며 동시에 하나의 작업 처리 할 수 있다

이벤트 루프 : 싱글스레드 약점 극복하기 위해 효휼적으로 작업 처리 하는 특성

블록킹 모델 : 실행 제어권을 다른곳에 넘기지 않아 다른 작업을 하지 못하고 대기 하는 것 동기
논 블록킹 모델  : 제어권 넘기면 다른 코드도 실행될 수 있기에 비동기

원시 : 타입 불리언 변환어려움

객체타입 :함수 다양한 자료 들어감

객체 리터널  : 사람이 이해할 수 있는 문자 약속된 기호를 사용해 값을 생성하는 표기법

프로퍼티 객체 상태 나타나는 값 (키와 벨류로 구성)

에러 핸들링 : 에러를 관리 하는 방법 , 예상치 못한 상황 대비

클래스 : 객체를 나타내기 위한 도구

생성자 : 클래스 내부에서 constructor()로 정의한 메서드

메서드는 객체(Object) 에 묶여 있는 함수

<aside>
🔑 Q4. 이번 주차의 중요 키워드를 선정하고, 이것을 정리하는 질문과 답변을 만들어 주세요 :-)

</aside>

여러분의 생각을 적어주세요

<aside>
🔑 Q5. 이번 주차의 중요 키워드를 선정하고, 이것을 정리하는 질문과 답변을 만들어 주세요 :-)

</aside>

여러분의 생각을 적어주세요
